-*- mode: markdown; -*-

# leela-network-iterator(7) -- protocol specification #

## SYNOPSIS ##

_leela_ network iterator protocol over _0mq \\zeromq\\_ [3]:
_unidirectional network iterators_

## DESCRIPTION ##

This page describes the network protocol used by leela to export a
_unidirecional network iterator_, something that allows the server to
start sending data back to the user while it is being generated. The
client is also given the ability to consume only a fraction of the
entire message, without imposing a performance penalty on the server.

You should be familiar with the _0mq_ library in order to read this
document. At very least you should know what _0mq multipart messages_
are and how to use them.
 
### CONVENTIONS IN THIS PAGE ###

Consider the following message description:

    0       1
    +-------+-------+
    | part0 | part1 |
    +-------+-------+

This represents a multipart message, in the `0mq` terms, with two
parts. The first part, contains the string _part0_ and the second part
contains the string _part1_.

There is also a variation to this format, which is used to
representing a variadic number of parts:

    0       1..n
    +-------+---------+
    | part0 | part1-n |
    +-------+---------+

All messages in this document are represented using this syntax. All
strings, unless otherwise noted, are _ascii_ encoded.

When representing a communication between a client and a server, a
more concise representation may get used:

    > part0 | part1 | ... | part_n

This represents user's request (notice the character *>* at the
beginning of the string). The server reply is represented with the
character *<*:

    < part0 | part1 | ... | part_n

## REQUEST-RESPONSE PROTOCOL ##

This protocol is used to implement the so called _unidirecional
iterators_. By _iterator_ we mean that the server sends data in
_chunks_ as the users reads them, instead of processing and buffering
everything upfront. And by _unidirecional_, as the name implies, that
it moves in one direction, and in this particular case, this direction
is always forward.

There are three different request messages:

*   `begin`: creates a channel;
*   `fetch`: requests more data from a specific channel;
*   `store`: writes data on the channel;
*   `close`: closes the channel;

Upon receiving a message, and obviously depending on the message
received, the server implementing this interface must reply with one
of the following messages:

*   `done`: signals success, in response to a `begin` or `close`
    message and may contain additional information;
*   `fail`: signals error, no further messages will be received after
    this;
*   `item`: contains a fragment of the response, usually in response
    to a `fetch` message;

### BEGIN MESSAGE ###

The first message must be `begin`. This creates a new channel and also
requests the information that needs to be retrieved. The syntax is the
following [2]:

    0             1       2..n
    +-------------+-------+-----------+
    | <SIGNATURE> | begin | <BIN-STR> |
    +-------------+-------+-----------+

<SIGNATURE> authenticates this message (more on this at the end of
this document). <BIN-STR> is an implementation dependent string.

The reply must be either `fail`, alongside the _error code_, or `done`
with the _channel_ that has been created. For instance, the reply to
the above query could be:

    0      1              2
    +------+--------------+----------+
    | fail | <ERROR-CODE> | <REASON> |
    +------+--------------+----------+

Meaning an error has occurred. <REASON> is an string that describes
the error (optional). Or:

    0      1
    +------+-----------+
    | done | <CHANNEL> |
    +------+-----------+

Which tells everything went fine and a new channel has been
created. Notice that <CHANNEL> is an opaque string.

### FETCH MESSAGE ###

After a successful `begin` the user may fetch data from the server. In
order to accomplish this, the following message must be sent:

    0             1       2           3..n
    +-------------+-------+-----------+-----------+
    | <SIGNATURE> | fetch | <CHANNEL> | <BIN-STR> |
    +-------------+-------+-----------+-----------+
                                      ^^^^^^^^^^^^^
                                      optional,
                                      implementation
                                      dependent

<CHANNEL> is the result of the `begin` message. Suppose you are
referencing a valid channel and the signature is valid:

    0             1       2
    +-------------+-------+---+
    | <SIGNATURE> | fetch | 1 |
    +-------------+-------+---+
    

The answer to the above request will either be:

    0      1              2
    +------+--------------+----------+
    | fail | <ERROR-CODE> | <REASON> |
    +------+--------------+----------+

or a `item`, meaning there are more items to fetch:

    0      1..n
    +------+-----------+
    | item | <BIN-STR> |
    +------+-----------+

or a `done` with or without payload indicating the _end of the stream_:

    0      1..n
    +------+-----------+
    | done | <BIN-STR> |
    +------+-----------+
           ^^^^^^^^^^^^^
           optional,
           same as item

When a `done` or `fail` messages are sent the server will send no
further messages. Users must then send a `close` message to purge any
resources associated with that channel.

### STORE MESSAGE ###

After the `begin` message the server may receive data from the user
using a `storage` message. The syntax is:

    0             1       2           3..n
    +-------------+-------+-----------+-----------+
    | <SIGNATURE> | store | <CHANNEL> | <BIN-STR> |
    +-------------+-------+-----------+-----------+
                                      ^^^^^^^^^^^^^
                                      optional,
                                      implementation
                                      dependent

This produces no result. Again, the format of *<BIN-STR>* is
implementation dependent.

### CLOSE MESSAGE ###

The user that decides he no longer needs any more data, may issue a
close prematurely, i.e., before reaching the _end of stream_:

    0             1       2           3
    +-------------+-------+-----------+--------+
    | <SIGNATURE> | close | <CHANNEL> | nowait |
    +-------------+-------+-----------+--------+
                                      ^^^^^^^^^
                                      optional

This will make the server release any resources associated with this
channel. Close should wait the server to finish its business unless
*nowait* is provided. The possible responses to this message are:

    0
    +------+
    | done |
    +------+

Or a failure:

    0      1              2 
    +------+--------------+----------+
    | fail | <ERROR-CODE> | <REASON> |
    +------+--------------+----------+

## SIGNATURE ##

The signature field is a string that has the following format:

    <USERNAME>:<TIMESTAMP>:<NONCE> <HMAC-MD5>

where:

*   <NONCE>: `/^[a-zA-Z0-9_-\.]+$/`, random string;
*   <USERNAME>: `/^[a-zA-Z0-9_-\.]+$/`;
*   <TIMESTAMP>: `/^[0-9]+$/`, seconds since epoch (1970/JAN/01 UTC);

<HMAC-MD5> is _hexencoded_ and it calculates using the following
algorithm [4]:

    HMAC-MD5(<SECRET>, <USERNAME>:<TIMESTAMP>:<NONCE>:<MESSAGE>)

Where <MESSAGE> is the message you want to authenticate. For instance,
considering the following parameters:

*   user: dgvncsz0f
*   nonce: 42
*   secret: foobar
*   message: beginfoobar
*   timestamp: 0

The following is a valid signature:

    0                                                 1
    +-------------------------------------------------+-------+
    | dgvncsz0f:0:42 6db61148df1a789106fc1c559cd45ee0 | begin |
    +---------------------------------------------------------+
    | foobar                                                  |
    +---------------------------------------------------------+

## MISC ##

### SECURITY CONSIDERATIONS ###

The service validating the signature must ensure the timestamp is
valid by checking it against a time frame of +/-5 minutes relative to
the server's clock. Also, servers should verify the _nounce_ [5]
string has never been seen before in order to avoid replay attacks.

The user must ensure the clock is not too far way from the
server. Using *NTP* is recommended. Also, they must generate unique
and not guessable _nounce_ strings.

When rejecting a message because of the signature servers should fill
the _reason_ field with a human readable explanation of what has
failed to assist library writers. Something like the following:

    0      1     2
    +------+-----+-----------------+
    | fail | 403 | signature error |
    +------+-----+-----------------+
    
    +------+-----+-----------------+
    | fail | 403 | timestamp error |
    +------+-----+-----------------+
    
    +------+-----+-----------------+
    | fail | 403 | nonce error     |
    +------+-----+-----------------+

    +------+-----+-----------------+
    | fail | 403 | invalid user    |
    +------+-----+-----------------+

### ERROR CODES ###

Error codes are numeric and their meaning is the same as defined by
the HTTP [2] specification, except we use only two classes of them:

*   4xx: user error;
*   5xx: server error;

### MAXIMUM MESSAGE SIZE ###

No single message may exceed _1Mbyte_ in size.

## REFERENCES ##

*   [1] [ZeroMQ Base-85 Encoding Algorithm](http://rfc.zeromq.org/spec:32)
*   [2] [Status Code Definitions](http://tools.ietf.org/html/rfc2616#section-10)
*   [3] [0mq \\zeromq\\ ](http://zeromq.org)
*   [4] [HMAC: Keyed-Hashing for Message Authentication](http://tools.ietf.org/html/rfc2104)
*   [5] [Cryptografic nonce](http://en.wikipedia.org/wiki/Cryptographic_nonce)

## AUTHORS ##

This manual page has been written by dsouza <dsouza@c0d3.xxx>.

## RESOURCES ##

Source code available at http://github.com/locaweb/leela

## COPYING ##

Please refer to COPYING file.
